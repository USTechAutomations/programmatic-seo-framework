// =============================================================================
// blog.ts - Markdown Blog Processing Utilities
// =============================================================================
// Handles reading markdown files, parsing front matter, and converting to HTML.
// Optimized for programmatic SEO with structured data support.
// =============================================================================

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { remark } from 'remark';
import html from 'remark-html';
import remarkGfm from 'remark-gfm';
import readingTime from 'reading-time';

// -----------------------------------------------------------------------------
// CONFIGURATION
// -----------------------------------------------------------------------------

const BLOG_DIRECTORY = path.join(process.cwd(), 'content/blog');
const CACHE = new Map<string, BlogPost>();

// -----------------------------------------------------------------------------
// TYPE DEFINITIONS
// -----------------------------------------------------------------------------

export interface BlogPostMeta {
  slug: string;
  title: string;
  description: string;
  date: string;
  author: string;
  tags: string[];
  category: string;
  featuredImage?: string;
  draft: boolean;
  readingTime: string;
  wordCount: number;
  // SEO-specific fields
  metaTitle?: string;        // Override for meta title
  metaDescription?: string;  // Override for meta description
  canonical?: string;        // Canonical URL if different
  noindex?: boolean;         // Exclude from indexing
  // Structured data fields
  faqItems?: FAQItem[];
  lastModified?: string;
  // Programmatic SEO fields
  templateType?: string;     // Which template generated this
  dataSource?: string;       // Where data came from
  autoGenerated?: boolean;   // Was this AI-generated
  reviewedBy?: string;       // Human reviewer
  reviewedAt?: string;       // Review timestamp
}

export interface FAQItem {
  question: string;
  answer: string;
}

export interface BlogPost extends BlogPostMeta {
  content: string;
  rawContent: string;  // Original markdown for processing
}

export interface BlogPostSummary {
  slug: string;
  title: string;
  description: string;
  date: string;
  tags: string[];
  readingTime: string;
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

function getSlugFromFilename(filename: string): string {
  return filename
    .replace(/\.md$/, '')
    .replace(/^\d{4}-\d{2}-\d{2}-/, '');
}

function ensureDirectory(): boolean {
  if (!fs.existsSync(BLOG_DIRECTORY)) {
    console.warn(`Blog directory not found: ${BLOG_DIRECTORY}`);
    return false;
  }
  return true;
}

function extractFAQFromContent(content: string): FAQItem[] {
  // Extract FAQ items from markdown content
  // Looks for ## FAQ section with Q: and A: patterns
  const faqSection = content.match(/## FAQ[\s\S]*?(?=## |$)/i);
  if (!faqSection) return [];

  const items: FAQItem[] = [];
  const qaPattern = /\*\*Q:\s*(.+?)\*\*\s*\n\s*A:\s*(.+?)(?=\*\*Q:|$)/gs;
  let match;

  while ((match = qaPattern.exec(faqSection[0])) !== null) {
    items.push({
      question: match[1].trim(),
      answer: match[2].trim(),
    });
  }

  return items;
}

// -----------------------------------------------------------------------------
// MAIN FUNCTIONS
// -----------------------------------------------------------------------------

export async function getAllPosts(): Promise<BlogPostMeta[]> {
  if (!ensureDirectory()) return [];

  const filenames = fs.readdirSync(BLOG_DIRECTORY)
    .filter(file => file.endsWith('.md'));

  const posts = await Promise.all(
    filenames.map(async filename => {
      const filePath = path.join(BLOG_DIRECTORY, filename);
      const fileContents = fs.readFileSync(filePath, 'utf8');
      const { data, content } = matter(fileContents);
      const stats = readingTime(content);
      const slug = data.slug || getSlugFromFilename(filename);
      const faqItems = data.faqItems || extractFAQFromContent(content);

      return {
        slug,
        title: data.title || 'Untitled',
        description: data.description || '',
        date: data.date ? new Date(data.date).toISOString() : new Date().toISOString(),
        author: data.author || 'US Tech Automations',
        tags: data.tags || [],
        category: data.category || 'General',
        featuredImage: data.featured_image || data.featuredImage,
        draft: data.draft || false,
        readingTime: stats.text,
        wordCount: stats.words,
        metaTitle: data.metaTitle,
        metaDescription: data.metaDescription,
        canonical: data.canonical,
        noindex: data.noindex || false,
        faqItems,
        lastModified: data.lastModified,
        templateType: data.templateType,
        dataSource: data.dataSource,
        autoGenerated: data.autoGenerated || false,
        reviewedBy: data.reviewedBy,
        reviewedAt: data.reviewedAt,
      } as BlogPostMeta;
    })
  );

  return posts
    .filter(post => process.env.NODE_ENV === 'development' || !post.draft)
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

export async function getPostBySlug(slug: string): Promise<BlogPost | null> {
  // Check cache first
  if (CACHE.has(slug)) {
    return CACHE.get(slug)!;
  }

  if (!ensureDirectory()) return null;

  const filenames = fs.readdirSync(BLOG_DIRECTORY);
  const matchingFile = filenames.find(filename => {
    const fileSlug = getSlugFromFilename(filename);
    return fileSlug === slug;
  });

  if (!matchingFile) return null;

  const filePath = path.join(BLOG_DIRECTORY, matchingFile);
  const fileContents = fs.readFileSync(filePath, 'utf8');
  const { data, content } = matter(fileContents);

  // Process markdown to HTML with GFM support
  const processedContent = await remark()
    .use(remarkGfm)  // Tables, strikethrough, etc.
    .use(html, { sanitize: false })
    .process(content);

  const htmlContent = processedContent.toString();
  const stats = readingTime(content);
  const faqItems = data.faqItems || extractFAQFromContent(content);

  const post: BlogPost = {
    slug,
    title: data.title || 'Untitled',
    description: data.description || '',
    date: data.date ? new Date(data.date).toISOString() : new Date().toISOString(),
    author: data.author || 'US Tech Automations',
    tags: data.tags || [],
    category: data.category || 'General',
    featuredImage: data.featured_image || data.featuredImage,
    draft: data.draft || false,
    readingTime: stats.text,
    wordCount: stats.words,
    metaTitle: data.metaTitle,
    metaDescription: data.metaDescription,
    canonical: data.canonical,
    noindex: data.noindex || false,
    faqItems,
    lastModified: data.lastModified,
    templateType: data.templateType,
    dataSource: data.dataSource,
    autoGenerated: data.autoGenerated || false,
    reviewedBy: data.reviewedBy,
    reviewedAt: data.reviewedAt,
    content: htmlContent,
    rawContent: content,
  };

  // Cache the post
  CACHE.set(slug, post);

  return post;
}

export async function getAllTags(): Promise<string[]> {
  const posts = await getAllPosts();
  const tagSet = new Set<string>();
  posts.forEach(post => post.tags.forEach(tag => tagSet.add(tag)));
  return Array.from(tagSet).sort();
}

export async function getAllCategories(): Promise<string[]> {
  const posts = await getAllPosts();
  const categorySet = new Set<string>();
  posts.forEach(post => categorySet.add(post.category));
  return Array.from(categorySet).sort();
}

export async function getAllSlugs(): Promise<string[]> {
  const posts = await getAllPosts();
  return posts.map(post => post.slug);
}

export async function getPostsByTag(tag: string): Promise<BlogPostMeta[]> {
  const posts = await getAllPosts();
  return posts.filter(post =>
    post.tags.some(t => t.toLowerCase() === tag.toLowerCase())
  );
}

export async function getPostsByCategory(category: string): Promise<BlogPostMeta[]> {
  const posts = await getAllPosts();
  return posts.filter(post =>
    post.category.toLowerCase() === category.toLowerCase()
  );
}

export async function getRelatedPosts(slug: string, limit = 3): Promise<BlogPostMeta[]> {
  const currentPost = await getPostBySlug(slug);
  if (!currentPost) return [];

  const allPosts = await getAllPosts();

  // Score posts by tag overlap
  const scored = allPosts
    .filter(post => post.slug !== slug)
    .map(post => {
      const tagOverlap = post.tags.filter(tag =>
        currentPost.tags.includes(tag)
      ).length;
      const sameCategory = post.category === currentPost.category ? 1 : 0;
      return { post, score: tagOverlap * 2 + sameCategory };
    })
    .sort((a, b) => b.score - a.score);

  return scored.slice(0, limit).map(s => s.post);
}

// -----------------------------------------------------------------------------
// STRUCTURED DATA GENERATORS
// -----------------------------------------------------------------------------

export function generateArticleSchema(post: BlogPost, siteUrl: string): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'Article',
    headline: post.title,
    description: post.description,
    image: post.featuredImage,
    datePublished: post.date,
    dateModified: post.lastModified || post.date,
    author: {
      '@type': 'Organization',
      name: post.author,
    },
    publisher: {
      '@type': 'Organization',
      name: 'US Tech Automations',
      logo: {
        '@type': 'ImageObject',
        url: `${siteUrl}/logo.png`,
      },
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': `${siteUrl}/blog/${post.slug}`,
    },
    wordCount: post.wordCount,
    articleSection: post.category,
    keywords: post.tags.join(', '),
  };
}

export function generateFAQSchema(faqItems: FAQItem[]): object | null {
  if (!faqItems || faqItems.length === 0) return null;

  return {
    '@context': 'https://schema.org',
    '@type': 'FAQPage',
    mainEntity: faqItems.map(item => ({
      '@type': 'Question',
      name: item.question,
      acceptedAnswer: {
        '@type': 'Answer',
        text: item.answer,
      },
    })),
  };
}

export function generateBreadcrumbSchema(post: BlogPost, siteUrl: string): object {
  return {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      {
        '@type': 'ListItem',
        position: 1,
        name: 'Home',
        item: siteUrl,
      },
      {
        '@type': 'ListItem',
        position: 2,
        name: 'Blog',
        item: `${siteUrl}/blog`,
      },
      {
        '@type': 'ListItem',
        position: 3,
        name: post.category,
        item: `${siteUrl}/blog/category/${encodeURIComponent(post.category.toLowerCase())}`,
      },
      {
        '@type': 'ListItem',
        position: 4,
        name: post.title,
        item: `${siteUrl}/blog/${post.slug}`,
      },
    ],
  };
}

// -----------------------------------------------------------------------------
// UTILITY FUNCTIONS FOR PROGRAMMATIC SEO
// -----------------------------------------------------------------------------

export function clearCache(): void {
  CACHE.clear();
}

export function getCacheStats(): { size: number; keys: string[] } {
  return {
    size: CACHE.size,
    keys: Array.from(CACHE.keys()),
  };
}
